// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const cleanAssetVtxos = `-- name: CleanAssetVtxos :exec
DELETE FROM asset_vtxo
`

func (q *Queries) CleanAssetVtxos(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanAssetVtxos)
	return err
}

const cleanTxs = `-- name: CleanTxs :exec
DELETE FROM tx
`

func (q *Queries) CleanTxs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanTxs)
	return err
}

const cleanUtxos = `-- name: CleanUtxos :exec
DELETE FROM utxo
`

func (q *Queries) CleanUtxos(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanUtxos)
	return err
}

const cleanVtxos = `-- name: CleanVtxos :exec
DELETE FROM vtxo
`

func (q *Queries) CleanVtxos(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanVtxos)
	return err
}

const deleteUtxo = `-- name: DeleteUtxo :exec
DELETE FROM utxo
WHERE txid = ?1 AND vout = ?2
`

type DeleteUtxoParams struct {
	Txid string
	Vout int64
}

func (q *Queries) DeleteUtxo(ctx context.Context, arg DeleteUtxoParams) error {
	_, err := q.db.ExecContext(ctx, deleteUtxo, arg.Txid, arg.Vout)
	return err
}

const insertAssetControl = `-- name: InsertAssetControl :exec
INSERT INTO asset_control (asset_id, control_asset_id) VALUES (?1, ?2)
ON CONFLICT (asset_id, control_asset_id) DO NOTHING
`

type InsertAssetControlParams struct {
	AssetID        string
	ControlAssetID string
}

func (q *Queries) InsertAssetControl(ctx context.Context, arg InsertAssetControlParams) error {
	_, err := q.db.ExecContext(ctx, insertAssetControl, arg.AssetID, arg.ControlAssetID)
	return err
}

const insertAssetVtxo = `-- name: InsertAssetVtxo :exec
INSERT INTO asset_vtxo (vtxo_txid, vtxo_vout, asset_id, amount) VALUES (?, ?, ?, ?)
`

type InsertAssetVtxoParams struct {
	VtxoTxid string
	VtxoVout int64
	AssetID  string
	Amount   int64
}

func (q *Queries) InsertAssetVtxo(ctx context.Context, arg InsertAssetVtxoParams) error {
	_, err := q.db.ExecContext(ctx, insertAssetVtxo,
		arg.VtxoTxid,
		arg.VtxoVout,
		arg.AssetID,
		arg.Amount,
	)
	return err
}

const insertTx = `-- name: InsertTx :exec
INSERT INTO tx (
    txid, txid_type, amount, type, created_at, hex, settled_by, settled, asset_packet
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertTxParams struct {
	Txid        string
	TxidType    string
	Amount      int64
	Type        string
	CreatedAt   int64
	Hex         sql.NullString
	SettledBy   sql.NullString
	Settled     bool
	AssetPacket sql.NullString
}

func (q *Queries) InsertTx(ctx context.Context, arg InsertTxParams) error {
	_, err := q.db.ExecContext(ctx, insertTx,
		arg.Txid,
		arg.TxidType,
		arg.Amount,
		arg.Type,
		arg.CreatedAt,
		arg.Hex,
		arg.SettledBy,
		arg.Settled,
		arg.AssetPacket,
	)
	return err
}

const insertUtxo = `-- name: InsertUtxo :exec
INSERT INTO utxo (
    txid, vout, script, amount, spent_by, spent, tapscripts, spendable_at, created_at, delay_value, delay_type, tx
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertUtxoParams struct {
	Txid        string
	Vout        int64
	Script      string
	Amount      int64
	SpentBy     sql.NullString
	Spent       bool
	Tapscripts  sql.NullString
	SpendableAt sql.NullInt64
	CreatedAt   sql.NullInt64
	DelayValue  sql.NullInt64
	DelayType   sql.NullString
	Tx          sql.NullString
}

func (q *Queries) InsertUtxo(ctx context.Context, arg InsertUtxoParams) error {
	_, err := q.db.ExecContext(ctx, insertUtxo,
		arg.Txid,
		arg.Vout,
		arg.Script,
		arg.Amount,
		arg.SpentBy,
		arg.Spent,
		arg.Tapscripts,
		arg.SpendableAt,
		arg.CreatedAt,
		arg.DelayValue,
		arg.DelayType,
		arg.Tx,
	)
	return err
}

const insertVtxo = `-- name: InsertVtxo :exec
INSERT INTO vtxo (
    txid, vout, script, amount, commitment_txids, spent_by, spent, preconfirmed, expires_at, created_at, swept, unrolled, settled_by, ark_txid
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertVtxoParams struct {
	Txid            string
	Vout            int64
	Script          string
	Amount          int64
	CommitmentTxids string
	SpentBy         sql.NullString
	Spent           bool
	Preconfirmed    bool
	ExpiresAt       int64
	CreatedAt       int64
	Swept           bool
	Unrolled        bool
	SettledBy       sql.NullString
	ArkTxid         sql.NullString
}

func (q *Queries) InsertVtxo(ctx context.Context, arg InsertVtxoParams) error {
	_, err := q.db.ExecContext(ctx, insertVtxo,
		arg.Txid,
		arg.Vout,
		arg.Script,
		arg.Amount,
		arg.CommitmentTxids,
		arg.SpentBy,
		arg.Spent,
		arg.Preconfirmed,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.Swept,
		arg.Unrolled,
		arg.SettledBy,
		arg.ArkTxid,
	)
	return err
}

const replaceTx = `-- name: ReplaceTx :exec
UPDATE tx
SET    txid       = ?1,
       txid_type  = ?2,
       amount     = ?3,
       type       = ?4,
       settled_by    = ?5,
       settled        = CASE WHEN ?5 IS NOT NULL THEN TRUE ELSE FALSE END,
       created_at = ?6,
       hex        = ?7
WHERE  txid = ?8
`

type ReplaceTxParams struct {
	NewTxid   string
	TxidType  string
	Amount    int64
	Type      string
	SettledBy sql.NullString
	CreatedAt int64
	Hex       sql.NullString
	OldTxid   string
}

func (q *Queries) ReplaceTx(ctx context.Context, arg ReplaceTxParams) error {
	_, err := q.db.ExecContext(ctx, replaceTx,
		arg.NewTxid,
		arg.TxidType,
		arg.Amount,
		arg.Type,
		arg.SettledBy,
		arg.CreatedAt,
		arg.Hex,
		arg.OldTxid,
	)
	return err
}

const selectAllTxs = `-- name: SelectAllTxs :many
SELECT txid, txid_type, amount, type, settled, created_at, hex, settled_by, asset_packet FROM tx
`

func (q *Queries) SelectAllTxs(ctx context.Context) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectAllTxs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.TxidType,
			&i.Amount,
			&i.Type,
			&i.Settled,
			&i.CreatedAt,
			&i.Hex,
			&i.SettledBy,
			&i.AssetPacket,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllUtxos = `-- name: SelectAllUtxos :many
SELECT txid, vout, script, amount, spent_by, spent, tapscripts, spendable_at, created_at, delay_value, delay_type, tx from utxo
`

func (q *Queries) SelectAllUtxos(ctx context.Context) ([]Utxo, error) {
	rows, err := q.db.QueryContext(ctx, selectAllUtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Utxo
	for rows.Next() {
		var i Utxo
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Script,
			&i.Amount,
			&i.SpentBy,
			&i.Spent,
			&i.Tapscripts,
			&i.SpendableAt,
			&i.CreatedAt,
			&i.DelayValue,
			&i.DelayType,
			&i.Tx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllVtxos = `-- name: SelectAllVtxos :many
SELECT txid, vout, script, amount, commitment_txids, spent_by, spent, expires_at, created_at, preconfirmed, swept, settled_by, unrolled, ark_txid, asset_id, asset_amount FROM asset_vtxo_vw
`

func (q *Queries) SelectAllVtxos(ctx context.Context) ([]AssetVtxoVw, error) {
	rows, err := q.db.QueryContext(ctx, selectAllVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssetVtxoVw
	for rows.Next() {
		var i AssetVtxoVw
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Script,
			&i.Amount,
			&i.CommitmentTxids,
			&i.SpentBy,
			&i.Spent,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.Preconfirmed,
			&i.Swept,
			&i.SettledBy,
			&i.Unrolled,
			&i.ArkTxid,
			&i.AssetID,
			&i.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSpendableVtxos = `-- name: SelectSpendableVtxos :many
SELECT txid, vout, script, amount, commitment_txids, spent_by, spent, expires_at, created_at, preconfirmed, swept, settled_by, unrolled, ark_txid, asset_id, asset_amount FROM asset_vtxo_vw
WHERE spent = false AND unrolled = false
`

func (q *Queries) SelectSpendableVtxos(ctx context.Context) ([]AssetVtxoVw, error) {
	rows, err := q.db.QueryContext(ctx, selectSpendableVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssetVtxoVw
	for rows.Next() {
		var i AssetVtxoVw
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Script,
			&i.Amount,
			&i.CommitmentTxids,
			&i.SpentBy,
			&i.Spent,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.Preconfirmed,
			&i.Swept,
			&i.SettledBy,
			&i.Unrolled,
			&i.ArkTxid,
			&i.AssetID,
			&i.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTxs = `-- name: SelectTxs :many
SELECT txid, txid_type, amount, type, settled, created_at, hex, settled_by, asset_packet FROM tx
WHERE txid IN (/*SLICE:txids*/?)
`

func (q *Queries) SelectTxs(ctx context.Context, txids []string) ([]Tx, error) {
	query := selectTxs
	var queryParams []interface{}
	if len(txids) > 0 {
		for _, v := range txids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:txids*/?", strings.Repeat(",?", len(txids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:txids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.TxidType,
			&i.Amount,
			&i.Type,
			&i.Settled,
			&i.CreatedAt,
			&i.Hex,
			&i.SettledBy,
			&i.AssetPacket,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUtxo = `-- name: SelectUtxo :one
SELECT txid, vout, script, amount, spent_by, spent, tapscripts, spendable_at, created_at, delay_value, delay_type, tx
FROM utxo
WHERE txid = ?1 AND vout = ?2
`

type SelectUtxoParams struct {
	Txid string
	Vout int64
}

func (q *Queries) SelectUtxo(ctx context.Context, arg SelectUtxoParams) (Utxo, error) {
	row := q.db.QueryRowContext(ctx, selectUtxo, arg.Txid, arg.Vout)
	var i Utxo
	err := row.Scan(
		&i.Txid,
		&i.Vout,
		&i.Script,
		&i.Amount,
		&i.SpentBy,
		&i.Spent,
		&i.Tapscripts,
		&i.SpendableAt,
		&i.CreatedAt,
		&i.DelayValue,
		&i.DelayType,
		&i.Tx,
	)
	return i, err
}

const selectVtxo = `-- name: SelectVtxo :many
SELECT txid, vout, script, amount, commitment_txids, spent_by, spent, expires_at, created_at, preconfirmed, swept, settled_by, unrolled, ark_txid, asset_id, asset_amount
FROM asset_vtxo_vw
WHERE txid = ?1 AND vout = ?2
`

type SelectVtxoParams struct {
	Txid string
	Vout int64
}

func (q *Queries) SelectVtxo(ctx context.Context, arg SelectVtxoParams) ([]AssetVtxoVw, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxo, arg.Txid, arg.Vout)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssetVtxoVw
	for rows.Next() {
		var i AssetVtxoVw
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Script,
			&i.Amount,
			&i.CommitmentTxids,
			&i.SpentBy,
			&i.Spent,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.Preconfirmed,
			&i.Swept,
			&i.SettledBy,
			&i.Unrolled,
			&i.ArkTxid,
			&i.AssetID,
			&i.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTx = `-- name: UpdateTx :exec
UPDATE tx
SET
    created_at     = COALESCE(?1, created_at),
    settled        = CASE WHEN ?2 IS NOT NULL THEN TRUE ELSE settled END,
    settled_by    = COALESCE(?2, settled_by)
WHERE txid = ?3
`

type UpdateTxParams struct {
	CreatedAt sql.NullInt64
	SettledBy interface{}
	Txid      string
}

func (q *Queries) UpdateTx(ctx context.Context, arg UpdateTxParams) error {
	_, err := q.db.ExecContext(ctx, updateTx, arg.CreatedAt, arg.SettledBy, arg.Txid)
	return err
}

const updateUtxo = `-- name: UpdateUtxo :exec
UPDATE utxo
SET
    spent = CASE WHEN ?1 IS TRUE THEN TRUE ELSE spent END,
    spent_by = COALESCE(?2, spent_by),
    created_at = COALESCE(?3, created_at),
    spendable_at = COALESCE(?4, spendable_at)
WHERE txid = ?5 AND vout = ?6
`

type UpdateUtxoParams struct {
	Spent       interface{}
	SpentBy     sql.NullString
	CreatedAt   sql.NullInt64
	SpendableAt sql.NullInt64
	Txid        string
	Vout        int64
}

func (q *Queries) UpdateUtxo(ctx context.Context, arg UpdateUtxoParams) error {
	_, err := q.db.ExecContext(ctx, updateUtxo,
		arg.Spent,
		arg.SpentBy,
		arg.CreatedAt,
		arg.SpendableAt,
		arg.Txid,
		arg.Vout,
	)
	return err
}

const updateVtxo = `-- name: UpdateVtxo :exec
UPDATE vtxo
SET
    spent = true,
    spent_by = ?1,
    settled_by = COALESCE(?2, settled_by),
    ark_txid = COALESCE(?3, ark_txid)
WHERE txid = ?4 AND vout = ?5
`

type UpdateVtxoParams struct {
	SpentBy   sql.NullString
	SettledBy sql.NullString
	ArkTxid   sql.NullString
	Txid      string
	Vout      int64
}

func (q *Queries) UpdateVtxo(ctx context.Context, arg UpdateVtxoParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxo,
		arg.SpentBy,
		arg.SettledBy,
		arg.ArkTxid,
		arg.Txid,
		arg.Vout,
	)
	return err
}

const upsertAsset = `-- name: UpsertAsset :exec
INSERT INTO asset (asset_id, metadata, immutable) VALUES (?1, ?2, ?3)
ON CONFLICT (asset_id) DO UPDATE SET
    metadata = COALESCE(EXCLUDED.metadata, metadata),
    immutable = COALESCE(EXCLUDED.immutable, immutable)
`

type UpsertAssetParams struct {
	AssetID   string
	Metadata  interface{}
	Immutable interface{}
}

func (q *Queries) UpsertAsset(ctx context.Context, arg UpsertAssetParams) error {
	_, err := q.db.ExecContext(ctx, upsertAsset, arg.AssetID, arg.Metadata, arg.Immutable)
	return err
}
