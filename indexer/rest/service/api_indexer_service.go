/*


No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: version not set
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// IndexerServiceAPIService IndexerServiceAPI service
type IndexerServiceAPIService service

type ApiIndexerServiceGetBatchSweepTransactionsRequest struct {
	ctx context.Context
	ApiService *IndexerServiceAPIService
	batchOutpointTxid string
	batchOutpointVout int32
}

func (r ApiIndexerServiceGetBatchSweepTransactionsRequest) Execute() (*GetBatchSweepTransactionsResponse, *http.Response, error) {
	return r.ApiService.IndexerServiceGetBatchSweepTransactionsExecute(r)
}

/*
IndexerServiceGetBatchSweepTransactions Method for IndexerServiceGetBatchSweepTransactions

GetBatchSweepTransactions returns the list of transaction (txid) that swept a given batch
output.
In most cases the list contains only one txid, meaning that all the amount locked for a
vtxo tree has been claimed back.
If any of the leaves of the tree have been unrolled onchain before the expiration, the
list will contain many txids instead.
In a binary tree with 4 or more leaves, 1 unroll causes the server to broadcast 3 txs to sweep
the whole rest of tree for example.
If a whole vtxo tree has been unrolled onchain, the list of txids for that batch output is
empty.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchOutpointTxid
 @param batchOutpointVout
 @return ApiIndexerServiceGetBatchSweepTransactionsRequest
*/
func (a *IndexerServiceAPIService) IndexerServiceGetBatchSweepTransactions(ctx context.Context, batchOutpointTxid string, batchOutpointVout int32) ApiIndexerServiceGetBatchSweepTransactionsRequest {
	return ApiIndexerServiceGetBatchSweepTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		batchOutpointTxid: batchOutpointTxid,
		batchOutpointVout: batchOutpointVout,
	}
}

// Execute executes the request
//  @return GetBatchSweepTransactionsResponse
func (a *IndexerServiceAPIService) IndexerServiceGetBatchSweepTransactionsExecute(r ApiIndexerServiceGetBatchSweepTransactionsRequest) (*GetBatchSweepTransactionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBatchSweepTransactionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexerServiceAPIService.IndexerServiceGetBatchSweepTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexer/batch/{batch_outpoint.txid}/{batch_outpoint.vout}/sweepTxs"
	localVarPath = strings.Replace(localVarPath, "{"+"batchOutpoint.txid"+"}", url.PathEscape(parameterValueToString(r.batchOutpointTxid, "batchOutpointTxid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"batchOutpoint.vout"+"}", url.PathEscape(parameterValueToString(r.batchOutpointVout, "batchOutpointVout")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndexerServiceGetCommitmentTxRequest struct {
	ctx context.Context
	ApiService *IndexerServiceAPIService
	txid string
}

func (r ApiIndexerServiceGetCommitmentTxRequest) Execute() (*GetCommitmentTxResponse, *http.Response, error) {
	return r.ApiService.IndexerServiceGetCommitmentTxExecute(r)
}

/*
IndexerServiceGetCommitmentTx Method for IndexerServiceGetCommitmentTx

GetCommitmentTx returns information about a specific commitment transaction identified by the
provided txid.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param txid
 @return ApiIndexerServiceGetCommitmentTxRequest
*/
func (a *IndexerServiceAPIService) IndexerServiceGetCommitmentTx(ctx context.Context, txid string) ApiIndexerServiceGetCommitmentTxRequest {
	return ApiIndexerServiceGetCommitmentTxRequest{
		ApiService: a,
		ctx: ctx,
		txid: txid,
	}
}

// Execute executes the request
//  @return GetCommitmentTxResponse
func (a *IndexerServiceAPIService) IndexerServiceGetCommitmentTxExecute(r ApiIndexerServiceGetCommitmentTxRequest) (*GetCommitmentTxResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCommitmentTxResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexerServiceAPIService.IndexerServiceGetCommitmentTx")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexer/commitmentTx/{txid}"
	localVarPath = strings.Replace(localVarPath, "{"+"txid"+"}", url.PathEscape(parameterValueToString(r.txid, "txid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndexerServiceGetConnectorsRequest struct {
	ctx context.Context
	ApiService *IndexerServiceAPIService
	txid string
	pageSize *int32
	pageIndex *int32
}

func (r ApiIndexerServiceGetConnectorsRequest) PageSize(pageSize int32) ApiIndexerServiceGetConnectorsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIndexerServiceGetConnectorsRequest) PageIndex(pageIndex int32) ApiIndexerServiceGetConnectorsRequest {
	r.pageIndex = &pageIndex
	return r
}

func (r ApiIndexerServiceGetConnectorsRequest) Execute() (*GetConnectorsResponse, *http.Response, error) {
	return r.ApiService.IndexerServiceGetConnectorsExecute(r)
}

/*
IndexerServiceGetConnectors Method for IndexerServiceGetConnectors

GetConnectors returns the tree of connectors for the provided commitment transaction.
The response includes a list of connector txs with details on the tree posistion and may
include pagination information if the results span multiple pages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param txid
 @return ApiIndexerServiceGetConnectorsRequest
*/
func (a *IndexerServiceAPIService) IndexerServiceGetConnectors(ctx context.Context, txid string) ApiIndexerServiceGetConnectorsRequest {
	return ApiIndexerServiceGetConnectorsRequest{
		ApiService: a,
		ctx: ctx,
		txid: txid,
	}
}

// Execute executes the request
//  @return GetConnectorsResponse
func (a *IndexerServiceAPIService) IndexerServiceGetConnectorsExecute(r ApiIndexerServiceGetConnectorsRequest) (*GetConnectorsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetConnectorsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexerServiceAPIService.IndexerServiceGetConnectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexer/commitmentTx/{txid}/connectors"
	localVarPath = strings.Replace(localVarPath, "{"+"txid"+"}", url.PathEscape(parameterValueToString(r.txid, "txid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.index", r.pageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndexerServiceGetForfeitTxsRequest struct {
	ctx context.Context
	ApiService *IndexerServiceAPIService
	txid string
	pageSize *int32
	pageIndex *int32
}

func (r ApiIndexerServiceGetForfeitTxsRequest) PageSize(pageSize int32) ApiIndexerServiceGetForfeitTxsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIndexerServiceGetForfeitTxsRequest) PageIndex(pageIndex int32) ApiIndexerServiceGetForfeitTxsRequest {
	r.pageIndex = &pageIndex
	return r
}

func (r ApiIndexerServiceGetForfeitTxsRequest) Execute() (*GetForfeitTxsResponse, *http.Response, error) {
	return r.ApiService.IndexerServiceGetForfeitTxsExecute(r)
}

/*
IndexerServiceGetForfeitTxs Method for IndexerServiceGetForfeitTxs

GetForfeitTxs returns the list of forfeit transactions that were submitted for the provided
commitment transaction.
The response may include pagination information if the results span multiple pages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param txid
 @return ApiIndexerServiceGetForfeitTxsRequest
*/
func (a *IndexerServiceAPIService) IndexerServiceGetForfeitTxs(ctx context.Context, txid string) ApiIndexerServiceGetForfeitTxsRequest {
	return ApiIndexerServiceGetForfeitTxsRequest{
		ApiService: a,
		ctx: ctx,
		txid: txid,
	}
}

// Execute executes the request
//  @return GetForfeitTxsResponse
func (a *IndexerServiceAPIService) IndexerServiceGetForfeitTxsExecute(r ApiIndexerServiceGetForfeitTxsRequest) (*GetForfeitTxsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetForfeitTxsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexerServiceAPIService.IndexerServiceGetForfeitTxs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexer/commitmentTx/{txid}/forfeitTxs"
	localVarPath = strings.Replace(localVarPath, "{"+"txid"+"}", url.PathEscape(parameterValueToString(r.txid, "txid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.index", r.pageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndexerServiceGetSubscriptionRequest struct {
	ctx context.Context
	ApiService *IndexerServiceAPIService
	subscriptionId string
}

func (r ApiIndexerServiceGetSubscriptionRequest) Execute() (*GetSubscriptionResponse, *http.Response, error) {
	return r.ApiService.IndexerServiceGetSubscriptionExecute(r)
}

/*
IndexerServiceGetSubscription Method for IndexerServiceGetSubscription

GetSubscription is a server-side streaming RPC which allows clients to receive real-time
notifications on transactions related to the subscribed vtxo scripts.
The subscription can be created or updated by using the SubscribeForScripts and
UnsubscribeForScripts RPCs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriptionId
 @return ApiIndexerServiceGetSubscriptionRequest
*/
func (a *IndexerServiceAPIService) IndexerServiceGetSubscription(ctx context.Context, subscriptionId string) ApiIndexerServiceGetSubscriptionRequest {
	return ApiIndexerServiceGetSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
//  @return GetSubscriptionResponse
func (a *IndexerServiceAPIService) IndexerServiceGetSubscriptionExecute(r ApiIndexerServiceGetSubscriptionRequest) (*GetSubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexerServiceAPIService.IndexerServiceGetSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexer/script/subscription/{subscription_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(parameterValueToString(r.subscriptionId, "subscriptionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/event-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndexerServiceGetVirtualTxsRequest struct {
	ctx context.Context
	ApiService *IndexerServiceAPIService
	txids []string
	pageSize *int32
	pageIndex *int32
}

func (r ApiIndexerServiceGetVirtualTxsRequest) PageSize(pageSize int32) ApiIndexerServiceGetVirtualTxsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIndexerServiceGetVirtualTxsRequest) PageIndex(pageIndex int32) ApiIndexerServiceGetVirtualTxsRequest {
	r.pageIndex = &pageIndex
	return r
}

func (r ApiIndexerServiceGetVirtualTxsRequest) Execute() (*GetVirtualTxsResponse, *http.Response, error) {
	return r.ApiService.IndexerServiceGetVirtualTxsExecute(r)
}

/*
IndexerServiceGetVirtualTxs Method for IndexerServiceGetVirtualTxs

GetVirtualTxs returns the virtual transactions in hex format for the specified txids.
The response may be paginated if the results span multiple pages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param txids
 @return ApiIndexerServiceGetVirtualTxsRequest
*/
func (a *IndexerServiceAPIService) IndexerServiceGetVirtualTxs(ctx context.Context, txids []string) ApiIndexerServiceGetVirtualTxsRequest {
	return ApiIndexerServiceGetVirtualTxsRequest{
		ApiService: a,
		ctx: ctx,
		txids: txids,
	}
}

// Execute executes the request
//  @return GetVirtualTxsResponse
func (a *IndexerServiceAPIService) IndexerServiceGetVirtualTxsExecute(r ApiIndexerServiceGetVirtualTxsRequest) (*GetVirtualTxsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVirtualTxsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexerServiceAPIService.IndexerServiceGetVirtualTxs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexer/virtualTx/{txids}"
	localVarPath = strings.Replace(localVarPath, "{"+"txids"+"}", url.PathEscape(parameterValueToString(r.txids, "txids")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if len(r.txids) < 1 {
		return localVarReturnValue, nil, reportError("txids must have at least 1 elements")
	}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.index", r.pageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndexerServiceGetVtxoChainRequest struct {
	ctx context.Context
	ApiService *IndexerServiceAPIService
	outpointTxid string
	outpointVout int32
	pageSize *int32
	pageIndex *int32
}

func (r ApiIndexerServiceGetVtxoChainRequest) PageSize(pageSize int32) ApiIndexerServiceGetVtxoChainRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIndexerServiceGetVtxoChainRequest) PageIndex(pageIndex int32) ApiIndexerServiceGetVtxoChainRequest {
	r.pageIndex = &pageIndex
	return r
}

func (r ApiIndexerServiceGetVtxoChainRequest) Execute() (*GetVtxoChainResponse, *http.Response, error) {
	return r.ApiService.IndexerServiceGetVtxoChainExecute(r)
}

/*
IndexerServiceGetVtxoChain Method for IndexerServiceGetVtxoChain

GetVtxoChain returns the the chain of ark txs that starts from spending any vtxo leaf and ends
with the creation of the provided vtxo outpoint.
The response may be paginated if the results span multiple pages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param outpointTxid
 @param outpointVout
 @return ApiIndexerServiceGetVtxoChainRequest
*/
func (a *IndexerServiceAPIService) IndexerServiceGetVtxoChain(ctx context.Context, outpointTxid string, outpointVout int32) ApiIndexerServiceGetVtxoChainRequest {
	return ApiIndexerServiceGetVtxoChainRequest{
		ApiService: a,
		ctx: ctx,
		outpointTxid: outpointTxid,
		outpointVout: outpointVout,
	}
}

// Execute executes the request
//  @return GetVtxoChainResponse
func (a *IndexerServiceAPIService) IndexerServiceGetVtxoChainExecute(r ApiIndexerServiceGetVtxoChainRequest) (*GetVtxoChainResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVtxoChainResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexerServiceAPIService.IndexerServiceGetVtxoChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexer/vtxo/{outpoint.txid}/{outpoint.vout}/chain"
	localVarPath = strings.Replace(localVarPath, "{"+"outpoint.txid"+"}", url.PathEscape(parameterValueToString(r.outpointTxid, "outpointTxid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"outpoint.vout"+"}", url.PathEscape(parameterValueToString(r.outpointVout, "outpointVout")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.index", r.pageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndexerServiceGetVtxoTreeRequest struct {
	ctx context.Context
	ApiService *IndexerServiceAPIService
	batchOutpointTxid string
	batchOutpointVout int32
	pageSize *int32
	pageIndex *int32
}

func (r ApiIndexerServiceGetVtxoTreeRequest) PageSize(pageSize int32) ApiIndexerServiceGetVtxoTreeRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIndexerServiceGetVtxoTreeRequest) PageIndex(pageIndex int32) ApiIndexerServiceGetVtxoTreeRequest {
	r.pageIndex = &pageIndex
	return r
}

func (r ApiIndexerServiceGetVtxoTreeRequest) Execute() (*GetVtxoTreeResponse, *http.Response, error) {
	return r.ApiService.IndexerServiceGetVtxoTreeExecute(r)
}

/*
IndexerServiceGetVtxoTree Method for IndexerServiceGetVtxoTree

GetVtxoTree returns the vtxo tree for the provided batch outpoint.
The response includes a list of txs with details on the tree posistion and may
include pagination information if the results span multiple pages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchOutpointTxid
 @param batchOutpointVout
 @return ApiIndexerServiceGetVtxoTreeRequest
*/
func (a *IndexerServiceAPIService) IndexerServiceGetVtxoTree(ctx context.Context, batchOutpointTxid string, batchOutpointVout int32) ApiIndexerServiceGetVtxoTreeRequest {
	return ApiIndexerServiceGetVtxoTreeRequest{
		ApiService: a,
		ctx: ctx,
		batchOutpointTxid: batchOutpointTxid,
		batchOutpointVout: batchOutpointVout,
	}
}

// Execute executes the request
//  @return GetVtxoTreeResponse
func (a *IndexerServiceAPIService) IndexerServiceGetVtxoTreeExecute(r ApiIndexerServiceGetVtxoTreeRequest) (*GetVtxoTreeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVtxoTreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexerServiceAPIService.IndexerServiceGetVtxoTree")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexer/batch/{batch_outpoint.txid}/{batch_outpoint.vout}/tree"
	localVarPath = strings.Replace(localVarPath, "{"+"batchOutpoint.txid"+"}", url.PathEscape(parameterValueToString(r.batchOutpointTxid, "batchOutpointTxid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"batchOutpoint.vout"+"}", url.PathEscape(parameterValueToString(r.batchOutpointVout, "batchOutpointVout")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.index", r.pageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndexerServiceGetVtxoTreeLeavesRequest struct {
	ctx context.Context
	ApiService *IndexerServiceAPIService
	batchOutpointTxid string
	batchOutpointVout int32
	pageSize *int32
	pageIndex *int32
}

func (r ApiIndexerServiceGetVtxoTreeLeavesRequest) PageSize(pageSize int32) ApiIndexerServiceGetVtxoTreeLeavesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIndexerServiceGetVtxoTreeLeavesRequest) PageIndex(pageIndex int32) ApiIndexerServiceGetVtxoTreeLeavesRequest {
	r.pageIndex = &pageIndex
	return r
}

func (r ApiIndexerServiceGetVtxoTreeLeavesRequest) Execute() (*GetVtxoTreeLeavesResponse, *http.Response, error) {
	return r.ApiService.IndexerServiceGetVtxoTreeLeavesExecute(r)
}

/*
IndexerServiceGetVtxoTreeLeaves Method for IndexerServiceGetVtxoTreeLeaves

GetVtxoTreeLeaves returns the list of leaves (vtxo outpoints) of the tree(s) for the
provided batch outpoint.
The response may be paginated if the results span multiple pages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchOutpointTxid
 @param batchOutpointVout
 @return ApiIndexerServiceGetVtxoTreeLeavesRequest
*/
func (a *IndexerServiceAPIService) IndexerServiceGetVtxoTreeLeaves(ctx context.Context, batchOutpointTxid string, batchOutpointVout int32) ApiIndexerServiceGetVtxoTreeLeavesRequest {
	return ApiIndexerServiceGetVtxoTreeLeavesRequest{
		ApiService: a,
		ctx: ctx,
		batchOutpointTxid: batchOutpointTxid,
		batchOutpointVout: batchOutpointVout,
	}
}

// Execute executes the request
//  @return GetVtxoTreeLeavesResponse
func (a *IndexerServiceAPIService) IndexerServiceGetVtxoTreeLeavesExecute(r ApiIndexerServiceGetVtxoTreeLeavesRequest) (*GetVtxoTreeLeavesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVtxoTreeLeavesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexerServiceAPIService.IndexerServiceGetVtxoTreeLeaves")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexer/batch/{batch_outpoint.txid}/{batch_outpoint.vout}/tree/leaves"
	localVarPath = strings.Replace(localVarPath, "{"+"batchOutpoint.txid"+"}", url.PathEscape(parameterValueToString(r.batchOutpointTxid, "batchOutpointTxid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"batchOutpoint.vout"+"}", url.PathEscape(parameterValueToString(r.batchOutpointVout, "batchOutpointVout")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.index", r.pageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndexerServiceGetVtxosRequest struct {
	ctx context.Context
	ApiService *IndexerServiceAPIService
	scripts *[]string
	outpoints *[]string
	spendableOnly *bool
	spentOnly *bool
	recoverableOnly *bool
	pageSize *int32
	pageIndex *int32
}

// Either specify a list of vtxo scripts.
func (r ApiIndexerServiceGetVtxosRequest) Scripts(scripts []string) ApiIndexerServiceGetVtxosRequest {
	r.scripts = &scripts
	return r
}

// Or specify a list of vtxo outpoints. The 2 filters are mutually exclusive.
func (r ApiIndexerServiceGetVtxosRequest) Outpoints(outpoints []string) ApiIndexerServiceGetVtxosRequest {
	r.outpoints = &outpoints
	return r
}

// Retrieve only spendable vtxos
func (r ApiIndexerServiceGetVtxosRequest) SpendableOnly(spendableOnly bool) ApiIndexerServiceGetVtxosRequest {
	r.spendableOnly = &spendableOnly
	return r
}

// Retrieve only spent vtxos.
func (r ApiIndexerServiceGetVtxosRequest) SpentOnly(spentOnly bool) ApiIndexerServiceGetVtxosRequest {
	r.spentOnly = &spentOnly
	return r
}

// Retrieve only recoverable vtxos (notes, subdust or swept vtxos). The 3 filters are mutually exclusive,
func (r ApiIndexerServiceGetVtxosRequest) RecoverableOnly(recoverableOnly bool) ApiIndexerServiceGetVtxosRequest {
	r.recoverableOnly = &recoverableOnly
	return r
}

func (r ApiIndexerServiceGetVtxosRequest) PageSize(pageSize int32) ApiIndexerServiceGetVtxosRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIndexerServiceGetVtxosRequest) PageIndex(pageIndex int32) ApiIndexerServiceGetVtxosRequest {
	r.pageIndex = &pageIndex
	return r
}

func (r ApiIndexerServiceGetVtxosRequest) Execute() (*GetVtxosResponse, *http.Response, error) {
	return r.ApiService.IndexerServiceGetVtxosExecute(r)
}

/*
IndexerServiceGetVtxos Method for IndexerServiceGetVtxos

GetVtxos returns the list of vtxos based on the provided filter. Vtxos can be retrieved either
by addresses or by outpoints, and optionally filtered by spendable or spent only.
The response may be paginated if the results span multiple pages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndexerServiceGetVtxosRequest
*/
func (a *IndexerServiceAPIService) IndexerServiceGetVtxos(ctx context.Context) ApiIndexerServiceGetVtxosRequest {
	return ApiIndexerServiceGetVtxosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetVtxosResponse
func (a *IndexerServiceAPIService) IndexerServiceGetVtxosExecute(r ApiIndexerServiceGetVtxosRequest) (*GetVtxosResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetVtxosResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexerServiceAPIService.IndexerServiceGetVtxos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexer/vtxos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scripts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scripts", r.scripts, "simple", "csv")
	}
	if r.outpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outpoints", r.outpoints, "simple", "csv")
	}
	if r.spendableOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "spendableOnly", r.spendableOnly, "form", "")
	}
	if r.spentOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "spentOnly", r.spentOnly, "form", "")
	}
	if r.recoverableOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recoverableOnly", r.recoverableOnly, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.index", r.pageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndexerServiceSubscribeForScriptsRequest struct {
	ctx context.Context
	ApiService *IndexerServiceAPIService
	subscribeForScriptsRequest *SubscribeForScriptsRequest
}

func (r ApiIndexerServiceSubscribeForScriptsRequest) SubscribeForScriptsRequest(subscribeForScriptsRequest SubscribeForScriptsRequest) ApiIndexerServiceSubscribeForScriptsRequest {
	r.subscribeForScriptsRequest = &subscribeForScriptsRequest
	return r
}

func (r ApiIndexerServiceSubscribeForScriptsRequest) Execute() (*SubscribeForScriptsResponse, *http.Response, error) {
	return r.ApiService.IndexerServiceSubscribeForScriptsExecute(r)
}

/*
IndexerServiceSubscribeForScripts Method for IndexerServiceSubscribeForScripts

SubscribeForScripts allows to subscribe for tx notifications related to the provided vtxo
scripts. It can also be used to update an existing subscribtion by adding new scripts to it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndexerServiceSubscribeForScriptsRequest
*/
func (a *IndexerServiceAPIService) IndexerServiceSubscribeForScripts(ctx context.Context) ApiIndexerServiceSubscribeForScriptsRequest {
	return ApiIndexerServiceSubscribeForScriptsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubscribeForScriptsResponse
func (a *IndexerServiceAPIService) IndexerServiceSubscribeForScriptsExecute(r ApiIndexerServiceSubscribeForScriptsRequest) (*SubscribeForScriptsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscribeForScriptsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexerServiceAPIService.IndexerServiceSubscribeForScripts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexer/script/subscribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscribeForScriptsRequest == nil {
		return localVarReturnValue, nil, reportError("subscribeForScriptsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscribeForScriptsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndexerServiceUnsubscribeForScriptsRequest struct {
	ctx context.Context
	ApiService *IndexerServiceAPIService
	unsubscribeForScriptsRequest *UnsubscribeForScriptsRequest
}

func (r ApiIndexerServiceUnsubscribeForScriptsRequest) UnsubscribeForScriptsRequest(unsubscribeForScriptsRequest UnsubscribeForScriptsRequest) ApiIndexerServiceUnsubscribeForScriptsRequest {
	r.unsubscribeForScriptsRequest = &unsubscribeForScriptsRequest
	return r
}

func (r ApiIndexerServiceUnsubscribeForScriptsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.IndexerServiceUnsubscribeForScriptsExecute(r)
}

/*
IndexerServiceUnsubscribeForScripts Method for IndexerServiceUnsubscribeForScripts

UnsubscribeForScripts allows to remove scripts from an existing subscription.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIndexerServiceUnsubscribeForScriptsRequest
*/
func (a *IndexerServiceAPIService) IndexerServiceUnsubscribeForScripts(ctx context.Context) ApiIndexerServiceUnsubscribeForScriptsRequest {
	return ApiIndexerServiceUnsubscribeForScriptsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IndexerServiceAPIService) IndexerServiceUnsubscribeForScriptsExecute(r ApiIndexerServiceUnsubscribeForScriptsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IndexerServiceAPIService.IndexerServiceUnsubscribeForScripts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/indexer/script/unsubscribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unsubscribeForScriptsRequest == nil {
		return localVarReturnValue, nil, reportError("unsubscribeForScriptsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unsubscribeForScriptsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
